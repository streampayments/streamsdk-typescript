{"version":3,"sources":["../../../src/adapters/express/checkout.ts","../../../src/adapters/express/webhooks.ts"],"sourcesContent":["import type { Request, Response, NextFunction } from 'express';\nimport StreamSDK from '../../sdk';\nimport type { CheckoutConfig, CheckoutRequest } from './types';\n\n/**\n * Creates an Express handler for Stream checkout flows\n *\n * @example\n * ```typescript\n * import express from 'express';\n * import { Checkout } from 'streampay-sdk/express';\n *\n * const app = express();\n *\n * app.get('/checkout', Checkout({\n *   apiKey: process.env.STREAM_API_KEY!,\n *   successUrl: 'https://myapp.com/success',\n *   returnUrl: 'https://myapp.com/cancel'\n * }));\n * ```\n *\n * Query parameters:\n * - products: Product ID(s), comma-separated for multiple (required)\n * - name: Custom name for payment link (optional, overrides defaultName)\n * - customerId: Existing customer/consumer ID (optional)\n * - customerEmail: Customer email (for new customers, optional)\n * - customerName: Customer name (for new customers, optional)\n * - customerPhone: Customer phone (for new customers, optional)\n * - metadata: URL-encoded JSON metadata (optional)\n */\nexport function Checkout(config: CheckoutConfig) {\n  const initOptions: any = {};\n  if (config.baseUrl) {\n    initOptions.baseUrl = config.baseUrl;\n  }\n  const streamClient = StreamSDK.init(config.apiKey, initOptions);\n\n  return async (req: CheckoutRequest, res: Response, next: NextFunction) => {\n    try {\n      const {\n        products,\n        name,\n        customerId,\n        customerEmail,\n        customerName,\n        customerPhone,\n        metadata\n      } = req.query;\n\n      // Parse product IDs\n      const productIds = products ? products.split(',').map(id => id.trim()) : [];\n\n      if (productIds.length === 0) {\n        return res.status(400).json({\n          error: 'At least one product ID is required'\n        });\n      }\n\n      // Determine payment link name (priority: query param > config default > generated)\n      const paymentLinkName = name || config.defaultName || `Checkout ${Date.now()}`;\n\n      // Prepare payment link data\n      const paymentLinkData: any = {\n        name: paymentLinkName,\n        items: productIds.map(id => ({\n          product_id: id,\n          quantity: 1\n        })),\n        success_redirect_url: config.successUrl,\n        failure_redirect_url: config.returnUrl || config.successUrl,\n        coupons: []\n      };\n\n      // Handle customer/consumer\n      let consumerId = customerId;\n\n      // If no customer ID but have customer details, create or find consumer\n      if (!consumerId && (customerPhone || customerEmail)) {\n        if (customerPhone) {\n          // Try to find existing consumer by phone\n          const consumers = await streamClient.listConsumers({ page: 1, size: 100 });\n          const existingConsumer = consumers.data?.find(c => c.phone_number === customerPhone);\n\n          if (existingConsumer) {\n            consumerId = existingConsumer.id;\n          } else if (customerName) {\n            // Create new consumer\n            const consumerData: any = {\n              phone_number: customerPhone,\n              name: customerName || 'Customer'\n            };\n            if (customerEmail) {\n              consumerData.email = customerEmail;\n            }\n            const newConsumer = await streamClient.createConsumer(consumerData);\n            consumerId = newConsumer.id;\n          }\n        }\n      }\n\n      if (consumerId) {\n        paymentLinkData.organization_consumer_id = consumerId;\n      }\n\n      // Add metadata if provided\n      if (metadata) {\n        try {\n          const parsedMetadata = JSON.parse(decodeURIComponent(metadata));\n          paymentLinkData.metadata = parsedMetadata;\n        } catch (e) {\n          // Invalid metadata format, skip\n        }\n      }\n\n      // Create payment link\n      const paymentLink = await streamClient.createPaymentLink(paymentLinkData);\n      const paymentUrl = streamClient.getPaymentUrl(paymentLink);\n\n      if (!paymentUrl) {\n        return res.status(500).json({\n          error: 'Failed to generate payment URL'\n        });\n      }\n\n      // Redirect to payment URL\n      res.redirect(paymentUrl);\n    } catch (error) {\n      next(error);\n    }\n  };\n}\n","import type { Request, Response, NextFunction } from 'express';\nimport { createHmac, timingSafeEqual } from 'crypto';\nimport type { WebhookConfig, WebhookPayload } from './types';\n\n/**\n * Creates an Express handler for Stream webhooks\n *\n * @example\n * ```typescript\n * import express from 'express';\n * import { Webhooks } from 'streampay-sdk/express';\n *\n * const app = express();\n *\n * app.post('/webhooks/stream', express.json(), Webhooks({\n *   apiKey: process.env.STREAM_API_KEY!,\n *   webhookSecret: process.env.STREAM_WEBHOOK_SECRET,\n *   onPaymentSucceeded: async (data) => {\n *     console.log('Payment succeeded:', data);\n *     // Handle payment success\n *   },\n *   onInvoiceCreated: async (data) => {\n *     console.log('Invoice created:', data);\n *     // Handle invoice creation\n *   }\n * }));\n * ```\n */\nexport function Webhooks(config: WebhookConfig) {\n  return async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      // Verify webhook signature if secret is provided\n      if (config.webhookSecret) {\n        const signatureHeader = req.headers['x-webhook-signature'] as string;\n\n        if (!signatureHeader) {\n          return res.status(401).json({\n            error: 'Missing webhook signature'\n          });\n        }\n\n        // Get raw body for signature verification\n        const rawBody = JSON.stringify(req.body);\n        const isValid = verifySignature(rawBody, signatureHeader, config.webhookSecret);\n\n        if (!isValid) {\n          return res.status(401).json({\n            error: 'Invalid webhook signature'\n          });\n        }\n      }\n\n      const payload: WebhookPayload = req.body;\n      const eventType = payload.event_type || payload.event || 'unknown';\n      const data = payload.data || payload;\n\n      // Route to specific event handlers based on Stream webhook events\n      switch (eventType) {\n        // Payment Events\n        case 'PAYMENT_SUCCEEDED':\n          if (config.onPaymentSucceeded) {\n            await config.onPaymentSucceeded(data);\n          }\n          break;\n\n        case 'PAYMENT_FAILED':\n          if (config.onPaymentFailed) {\n            await config.onPaymentFailed(data);\n          }\n          break;\n\n        case 'PAYMENT_CANCELED':\n          if (config.onPaymentCanceled) {\n            await config.onPaymentCanceled(data);\n          }\n          break;\n\n        case 'PAYMENT_REFUNDED':\n          if (config.onPaymentRefunded) {\n            await config.onPaymentRefunded(data);\n          }\n          break;\n\n        case 'PAYMENT_MARKED_AS_PAID':\n          if (config.onPaymentMarkedAsPaid) {\n            await config.onPaymentMarkedAsPaid(data);\n          }\n          break;\n\n        // Invoice Events\n        case 'INVOICE_CREATED':\n          if (config.onInvoiceCreated) {\n            await config.onInvoiceCreated(data);\n          }\n          break;\n\n        case 'INVOICE_SENT':\n          if (config.onInvoiceSent) {\n            await config.onInvoiceSent(data);\n          }\n          break;\n\n        case 'INVOICE_ACCEPTED':\n          if (config.onInvoiceAccepted) {\n            await config.onInvoiceAccepted(data);\n          }\n          break;\n\n        case 'INVOICE_REJECTED':\n          if (config.onInvoiceRejected) {\n            await config.onInvoiceRejected(data);\n          }\n          break;\n\n        case 'INVOICE_COMPLETED':\n          if (config.onInvoiceCompleted) {\n            await config.onInvoiceCompleted(data);\n          }\n          break;\n\n        case 'INVOICE_CANCELED':\n          if (config.onInvoiceCanceled) {\n            await config.onInvoiceCanceled(data);\n          }\n          break;\n\n        case 'INVOICE_UPDATED':\n          if (config.onInvoiceUpdated) {\n            await config.onInvoiceUpdated(data);\n          }\n          break;\n\n        // Subscription Events\n        case 'SUBSCRIPTION_CREATED':\n          if (config.onSubscriptionCreated) {\n            await config.onSubscriptionCreated(data);\n          }\n          break;\n\n        case 'SUBSCRIPTION_UPDATED':\n          if (config.onSubscriptionUpdated) {\n            await config.onSubscriptionUpdated(data);\n          }\n          break;\n\n        case 'SUBSCRIPTION_CANCELED':\n          if (config.onSubscriptionCanceled) {\n            await config.onSubscriptionCanceled(data);\n          }\n          break;\n\n        default:\n          // Fall through to catch-all handler\n          break;\n      }\n\n      // Call catch-all handler if provided\n      if (config.onWebhook) {\n        await config.onWebhook(eventType, data);\n      }\n\n      // Acknowledge receipt\n      res.status(200).json({ received: true });\n    } catch (error) {\n      next(error);\n    }\n  };\n}\n\n/**\n * Verify webhook signature using HMAC-SHA256\n *\n * Stream webhook signature format: t={timestamp},v1={signature}\n * Signed content: \"{timestamp}.{raw_request_body}\"\n */\nfunction verifySignature(rawBody: string, signatureHeader: string, secret: string): boolean {\n  try {\n    // Parse signature header: t=1234567890,v1=abcdef...\n    const parts = signatureHeader.split(',');\n    const timestamp = parts.find(p => p.startsWith('t='))?.substring(2);\n    const signature = parts.find(p => p.startsWith('v1='))?.substring(3);\n\n    if (!timestamp || !signature) {\n      return false;\n    }\n\n    // Check if timestamp is within 5 minutes (300 seconds) to prevent replay attacks\n    const currentTime = Math.floor(Date.now() / 1000);\n    const timeDiff = currentTime - parseInt(timestamp);\n    if (timeDiff > 300) {\n      console.warn('Webhook signature timestamp too old:', timeDiff, 'seconds');\n      return false;\n    }\n\n    // Compute expected signature\n    const signedPayload = `${timestamp}.${rawBody}`;\n    const expectedSignature = createHmac('sha256', secret)\n      .update(signedPayload)\n      .digest('hex');\n\n    // Constant-time comparison to prevent timing attacks\n    const signatureBuffer = Buffer.from(signature);\n    const expectedBuffer = Buffer.from(expectedSignature);\n\n    if (signatureBuffer.length !== expectedBuffer.length) {\n      return false;\n    }\n\n    return timingSafeEqual(signatureBuffer, expectedBuffer);\n  } catch (error) {\n    console.error('Webhook signature verification error:', error);\n    return false;\n  }\n}\n"],"mappings":";;;;;AA8BO,SAAS,SAAS,QAAwB;AAC/C,QAAM,cAAmB,CAAC;AAC1B,MAAI,OAAO,SAAS;AAClB,gBAAY,UAAU,OAAO;AAAA,EAC/B;AACA,QAAM,eAAe,UAAU,KAAK,OAAO,QAAQ,WAAW;AAE9D,SAAO,OAAO,KAAsB,KAAe,SAAuB;AACxE,QAAI;AACF,YAAM;AAAA,QACJ;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,IAAI,IAAI;AAGR,YAAM,aAAa,WAAW,SAAS,MAAM,GAAG,EAAE,IAAI,QAAM,GAAG,KAAK,CAAC,IAAI,CAAC;AAE1E,UAAI,WAAW,WAAW,GAAG;AAC3B,eAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,UAC1B,OAAO;AAAA,QACT,CAAC;AAAA,MACH;AAGA,YAAM,kBAAkB,QAAQ,OAAO,eAAe,YAAY,KAAK,IAAI,CAAC;AAG5E,YAAM,kBAAuB;AAAA,QAC3B,MAAM;AAAA,QACN,OAAO,WAAW,IAAI,SAAO;AAAA,UAC3B,YAAY;AAAA,UACZ,UAAU;AAAA,QACZ,EAAE;AAAA,QACF,sBAAsB,OAAO;AAAA,QAC7B,sBAAsB,OAAO,aAAa,OAAO;AAAA,QACjD,SAAS,CAAC;AAAA,MACZ;AAGA,UAAI,aAAa;AAGjB,UAAI,CAAC,eAAe,iBAAiB,gBAAgB;AACnD,YAAI,eAAe;AAEjB,gBAAM,YAAY,MAAM,aAAa,cAAc,EAAE,MAAM,GAAG,MAAM,IAAI,CAAC;AACzE,gBAAM,mBAAmB,UAAU,MAAM,KAAK,OAAK,EAAE,iBAAiB,aAAa;AAEnF,cAAI,kBAAkB;AACpB,yBAAa,iBAAiB;AAAA,UAChC,WAAW,cAAc;AAEvB,kBAAM,eAAoB;AAAA,cACxB,cAAc;AAAA,cACd,MAAM,gBAAgB;AAAA,YACxB;AACA,gBAAI,eAAe;AACjB,2BAAa,QAAQ;AAAA,YACvB;AACA,kBAAM,cAAc,MAAM,aAAa,eAAe,YAAY;AAClE,yBAAa,YAAY;AAAA,UAC3B;AAAA,QACF;AAAA,MACF;AAEA,UAAI,YAAY;AACd,wBAAgB,2BAA2B;AAAA,MAC7C;AAGA,UAAI,UAAU;AACZ,YAAI;AACF,gBAAM,iBAAiB,KAAK,MAAM,mBAAmB,QAAQ,CAAC;AAC9D,0BAAgB,WAAW;AAAA,QAC7B,SAAS,GAAG;AAAA,QAEZ;AAAA,MACF;AAGA,YAAM,cAAc,MAAM,aAAa,kBAAkB,eAAe;AACxE,YAAM,aAAa,aAAa,cAAc,WAAW;AAEzD,UAAI,CAAC,YAAY;AACf,eAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,UAC1B,OAAO;AAAA,QACT,CAAC;AAAA,MACH;AAGA,UAAI,SAAS,UAAU;AAAA,IACzB,SAAS,OAAO;AACd,WAAK,KAAK;AAAA,IACZ;AAAA,EACF;AACF;;;ACjIA,SAAS,YAAY,uBAAuB;AA2BrC,SAAS,SAAS,QAAuB;AAC9C,SAAO,OAAO,KAAc,KAAe,SAAuB;AAChE,QAAI;AAEF,UAAI,OAAO,eAAe;AACxB,cAAM,kBAAkB,IAAI,QAAQ,qBAAqB;AAEzD,YAAI,CAAC,iBAAiB;AACpB,iBAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,YAC1B,OAAO;AAAA,UACT,CAAC;AAAA,QACH;AAGA,cAAM,UAAU,KAAK,UAAU,IAAI,IAAI;AACvC,cAAM,UAAU,gBAAgB,SAAS,iBAAiB,OAAO,aAAa;AAE9E,YAAI,CAAC,SAAS;AACZ,iBAAO,IAAI,OAAO,GAAG,EAAE,KAAK;AAAA,YAC1B,OAAO;AAAA,UACT,CAAC;AAAA,QACH;AAAA,MACF;AAEA,YAAM,UAA0B,IAAI;AACpC,YAAM,YAAY,QAAQ,cAAc,QAAQ,SAAS;AACzD,YAAM,OAAO,QAAQ,QAAQ;AAG7B,cAAQ,WAAW;AAAA;AAAA,QAEjB,KAAK;AACH,cAAI,OAAO,oBAAoB;AAC7B,kBAAM,OAAO,mBAAmB,IAAI;AAAA,UACtC;AACA;AAAA,QAEF,KAAK;AACH,cAAI,OAAO,iBAAiB;AAC1B,kBAAM,OAAO,gBAAgB,IAAI;AAAA,UACnC;AACA;AAAA,QAEF,KAAK;AACH,cAAI,OAAO,mBAAmB;AAC5B,kBAAM,OAAO,kBAAkB,IAAI;AAAA,UACrC;AACA;AAAA,QAEF,KAAK;AACH,cAAI,OAAO,mBAAmB;AAC5B,kBAAM,OAAO,kBAAkB,IAAI;AAAA,UACrC;AACA;AAAA,QAEF,KAAK;AACH,cAAI,OAAO,uBAAuB;AAChC,kBAAM,OAAO,sBAAsB,IAAI;AAAA,UACzC;AACA;AAAA;AAAA,QAGF,KAAK;AACH,cAAI,OAAO,kBAAkB;AAC3B,kBAAM,OAAO,iBAAiB,IAAI;AAAA,UACpC;AACA;AAAA,QAEF,KAAK;AACH,cAAI,OAAO,eAAe;AACxB,kBAAM,OAAO,cAAc,IAAI;AAAA,UACjC;AACA;AAAA,QAEF,KAAK;AACH,cAAI,OAAO,mBAAmB;AAC5B,kBAAM,OAAO,kBAAkB,IAAI;AAAA,UACrC;AACA;AAAA,QAEF,KAAK;AACH,cAAI,OAAO,mBAAmB;AAC5B,kBAAM,OAAO,kBAAkB,IAAI;AAAA,UACrC;AACA;AAAA,QAEF,KAAK;AACH,cAAI,OAAO,oBAAoB;AAC7B,kBAAM,OAAO,mBAAmB,IAAI;AAAA,UACtC;AACA;AAAA,QAEF,KAAK;AACH,cAAI,OAAO,mBAAmB;AAC5B,kBAAM,OAAO,kBAAkB,IAAI;AAAA,UACrC;AACA;AAAA,QAEF,KAAK;AACH,cAAI,OAAO,kBAAkB;AAC3B,kBAAM,OAAO,iBAAiB,IAAI;AAAA,UACpC;AACA;AAAA;AAAA,QAGF,KAAK;AACH,cAAI,OAAO,uBAAuB;AAChC,kBAAM,OAAO,sBAAsB,IAAI;AAAA,UACzC;AACA;AAAA,QAEF,KAAK;AACH,cAAI,OAAO,uBAAuB;AAChC,kBAAM,OAAO,sBAAsB,IAAI;AAAA,UACzC;AACA;AAAA,QAEF,KAAK;AACH,cAAI,OAAO,wBAAwB;AACjC,kBAAM,OAAO,uBAAuB,IAAI;AAAA,UAC1C;AACA;AAAA,QAEF;AAEE;AAAA,MACJ;AAGA,UAAI,OAAO,WAAW;AACpB,cAAM,OAAO,UAAU,WAAW,IAAI;AAAA,MACxC;AAGA,UAAI,OAAO,GAAG,EAAE,KAAK,EAAE,UAAU,KAAK,CAAC;AAAA,IACzC,SAAS,OAAO;AACd,WAAK,KAAK;AAAA,IACZ;AAAA,EACF;AACF;AAQA,SAAS,gBAAgB,SAAiB,iBAAyB,QAAyB;AAC1F,MAAI;AAEF,UAAM,QAAQ,gBAAgB,MAAM,GAAG;AACvC,UAAM,YAAY,MAAM,KAAK,OAAK,EAAE,WAAW,IAAI,CAAC,GAAG,UAAU,CAAC;AAClE,UAAM,YAAY,MAAM,KAAK,OAAK,EAAE,WAAW,KAAK,CAAC,GAAG,UAAU,CAAC;AAEnE,QAAI,CAAC,aAAa,CAAC,WAAW;AAC5B,aAAO;AAAA,IACT;AAGA,UAAM,cAAc,KAAK,MAAM,KAAK,IAAI,IAAI,GAAI;AAChD,UAAM,WAAW,cAAc,SAAS,SAAS;AACjD,QAAI,WAAW,KAAK;AAClB,cAAQ,KAAK,wCAAwC,UAAU,SAAS;AACxE,aAAO;AAAA,IACT;AAGA,UAAM,gBAAgB,GAAG,SAAS,IAAI,OAAO;AAC7C,UAAM,oBAAoB,WAAW,UAAU,MAAM,EAClD,OAAO,aAAa,EACpB,OAAO,KAAK;AAGf,UAAM,kBAAkB,OAAO,KAAK,SAAS;AAC7C,UAAM,iBAAiB,OAAO,KAAK,iBAAiB;AAEpD,QAAI,gBAAgB,WAAW,eAAe,QAAQ;AACpD,aAAO;AAAA,IACT;AAEA,WAAO,gBAAgB,iBAAiB,cAAc;AAAA,EACxD,SAAS,OAAO;AACd,YAAQ,MAAM,yCAAyC,KAAK;AAC5D,WAAO;AAAA,EACT;AACF;","names":[]}